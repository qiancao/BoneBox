"""

Fit MTF and NPS

"""
import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt

from scipy.interpolate import interp1d
from scipy import optimize

import sys
sys.path.append("../bonebox/metrics/")

from FeaturesRadiomics import *

def computeNPS(rois,voxSize):
    """
    Compute noise power spectra from ROIs

    Parameters
    ----------
    rois : list of numpy arrays (must be the same size)
        list of noise ROIs.
    voxSize : tuple
        voxel dimension in the corresponding directions.

    Returns
    -------
    NPS: noise power spectra
    freqs: frequency vector for each axis

    """
    
    ndim = rois[0].ndim
    shape = rois[0].shape
    
    freqs = []
    for ind, Nvoxels in enumerate(shape):
        freqs.append(np.fft.fftfreq(Nvoxels,voxSize[ind]))
    
    N = len(rois)
    # A = np.prod(voxSize)
    
    Froi = np.zeros(shape,dtype=np.float64)
    for n, roi in enumerate(rois):
         Froi = Froi + np.abs(np.fft.fftn(roi, axes=tuple(range(ndim))))**2
    
    # NPS = Froi / N / A
    NPS = np.prod(voxSize) / np.prod(shape) * (Froi / N)
    
    return NPS, freqs

def applyMTF(image, MTF):
    # Apply blur to image
    
    # assumes MTF axes is consistent with image
    assert image.shape == MTF.shape
    
    imageFFT = np.fft.fftn(image,axes=tuple(range(image.ndim)))
    image_filtered = abs(np.fft.ifftn(imageFFT * MTF, axes=tuple(range(image.ndim))))
    
    return image_filtered

def applySampling(image, voxSize, voxSizeNew):
    # TODO: check on use of histogramdd
    
    dimsNew = (image.shape * np.array(voxSize) // np.array(voxSizeNew)).astype(int)
    
    shape = image.shape
    # xxx,yyy,zzz = np.meshgrid(np.arange(shape[0]),np.arange(shape[1]),np.arange(shape[2]))
    # TODO: think about how to do this properly
    x,y,z = np.meshgrid(np.linspace(0,shape[0],dimsNew[0]).astype(int),
                                 np.linspace(0,shape[1],dimsNew[1]).astype(int),
                                 np.linspace(0,shape[2],dimsNew[2]).astype(int))

    imageNew = ndimage.map_coordinates(image, [x.flatten(), y.flatten(), z.flatten()])
    
    imageNew = np.reshape(imageNew,dimsNew)
    
    # return ndimage.zoom(image, zoom, prefilter=False)
    return imageNew

def noisePoisson(size,plambda=1000,seed=None):
    rng = np.random.default_rng(seed)
    return rng.poisson(plambda,size) - plambda

def noiseNormal(size,mean=0,std=1,seed=None):
    rng = np.random.default_rng(seed)
    return rng.normal(mean,std,size)

def getFreqs(shape,voxSize):
    freqs = []
    for ind, Nvoxels in enumerate(shape):
        freqs.append(np.fft.fftfreq(Nvoxels,voxSize[ind]))
    return freqs

def Gaussian3DUncorrelated(xxx,yyy,zzz,std):
    return np.exp((-xxx**2/std[0]**2-yyy**2/std[1]**2-zzz**2/std[2]**2)/2)

def make3DMTFGaussian(freqs, std):
    xxx,yyy,zzz = np.meshgrid(*freqs)
    return Gaussian3DUncorrelated(xxx,yyy,zzz,std)

def shapeNPS(noise, NPS):
    # deprecated
    
    # assumes NPS axes is consistent with image
    assert noise.shape == NPS.shape
    
    noiseFFT = np.fft.fftn(noise**2,axes=tuple(range(noise.ndim)))
    noise_filtered = np.abs(np.fft.ifftn(noiseFFT * np.sqrt(NPS), axes=tuple(range(noise.ndim))))
    
    return noise_filtered

def NPS2noise(NPS,seed=None):
    """
    Generates noise from a white noise and power spectra
    Note: frequency axes must match that of the image
    see https://www.mathworks.com/matlabcentral/fileexchange/36462-noise-power-spectrum
    """
    
    rng = np.random.default_rng(seed)
    v = rng.random(NPS.shape,dtype=np.float64)
    F = NPS * (np.cos(2*np.pi*v) + 1j*np.sin(2*np.pi*v))
    f = np.fft.ifftn(F, axes=tuple(range(NPS.ndim)))
    noise = np.real(f) + np.imag(f)
    
    return noise

def makeNullCone(freqs,alpha=1,beta=0.5):
    xxx,yyy,zzz = np.meshgrid(*freqs)
    cone = alpha * np.sqrt(xxx**2+yyy**2)
    cone = np.maximum(cone - beta * abs(zzz),0)
    return cone

def makeNPSRamp(freqs,alpha=1):
    xxx,yyy,zzz = np.meshgrid(*freqs)
    cone = alpha * np.sqrt(xxx**2+yyy**2)
    return cone

def integrateNPS(NPS,freqs):
    df = 1
    for ind, f in enumerate(freqs):
        df = df * np.abs(f[1]-f[0]) # integrate noise power
    return np.sum(NPS) * df

def simulateImage(roi, voxSize, voxSizeNew, stdMTF, noise_std, seed=None):
    
    roi = applySampling(roi, voxSize, voxSizeNew)
    voxSize = voxSizeNew
    
    # # normalize to 0 and 1, scale to bone HU (this is done outside the function now via applyScaling)
    # roi = (roi - np.min(roi)) / (np.max(roi) - np.min(roi))
    # roi = roi * boneHU
    
    # get frequency axis
    freqs = getFreqs(roi.shape,voxSizeNew)
    
    T = make3DMTFGaussian(freqs,stdMTF)
    roiT = applyMTF(roi,T)
    
    ramp = makeNPSRamp(freqs)
    
    S = (T**2)*ramp
    S = S / integrateNPS(S,freqs) * noise_std # TODO: should be squqred
    
    noiseS = NPS2noise(S,seed=seed) * (noise_std**2)
    
    roi_final = roiT+noiseS
    
    return roi_final, noiseS, roiT, S, T

def insert01(x,y):
    x = np.insert(x,0,0)
    y = np.insert(y,0,1)
    return (x,y)

def mtfnps(rScale,nScale):

    # returns 1D: freqs (in lp/cm), mtf, nps
    vscale = 1 # voxel scaling
    voxSizeNew = np.array((0.1,0.1,0.1)) * vscale # this is in mm
    freqs = getFreqs((201,)*3,voxSizeNew)
    
    stdMTF = np.array([1.8,1.8,0.5]) * rScale
    T = make3DMTFGaussian(freqs,stdMTF)

    noise_std = 180 * nScale

    ramp = makeNPSRamp(freqs)
    S = (T**2)*ramp
    S = S / integrateNPS(S,freqs) * noise_std # TODO: should be squqred

    Tip = np.mean(T,axis=2) # normalized to (0,1)
    Tip = Tip/Tip[0,0]
    Sip = np.sum(S,axis=2) * (1/(voxSizeNew[2]*len(freqs[0]))) # TODO: this is a sum, we need an integral

    return freqs[0][:101]*10, Tip[:101,0], Sip[:101,0]

def mtf(rScale, x):
    # find in-plane mtf at the frequencies listed
    freqs, T, S = mtfnps(rScale,1)
    f = interp1d(freqs, T)
    return f(x)

def nps(rScale, x):
    # fine in-plane nps at the frequencies listed
    freqs, T, S = mtfnps(rScale,1)
    f = interp1d(freqs, S)
    return f(x)

def fit_mtf(x,y):
    cost = lambda r: np.sqrt(np.mean((y - mtf(r,x))**2)) # RMSE
    res = optimize.minimize_scalar(cost)

    print(res)

    return res.x

def mtf50(rScale):
    # 2.355*sigma

    return 2.355*1.8*rScale/2 * 10

def normmax(x):
    # normalize by the max
    return x/np.max(x)

if __name__ == "__main__":

    nScales = np.linspace(1.2, 0.2, 60)
    rScales = np.linspace(1, 0.3, 40)

    figuresDir = "./FiguresImageQuality"
    
    outDir = "/projects01/didsr-aiml/qian.cao/20220809_fit_MTF_NPS"
    os.makedirs(outDir,exist_ok=True)

    ##### These are MTFs

    CSV = "Rajendran 2022 Radiology PCCT Fig 1-1.csv"
    pathCSV = os.path.join(figuresDir,CSV)
    df = pd.read_csv(pathCSV)

    x_pcct_br96, y_pcct_br96 = insert01(df.iloc[1:29,2].to_numpy().astype(float),df.iloc[1:29,3].to_numpy().astype(float))
    rScale_pcct_br96 = fit_mtf(x_pcct_br96, y_pcct_br96)

    x_pcct_br76, y_pcct_br76 = insert01(df.iloc[1:29,0].to_numpy().astype(float),df.iloc[1:29,1].to_numpy().astype(float))
    rScale_pcct_br76 = fit_mtf(x_pcct_br76, y_pcct_br76)

    CSV = "Canon Medical System – Fig 4.csv"
    pathCSV = os.path.join(figuresDir,CSV)
    df = pd.read_csv(pathCSV)

    x_uhr_hr, y_uhr_hr = insert01(df.iloc[1:43,0].to_numpy().astype(float),df.iloc[1:43,1].to_numpy().astype(float))
    rScale_uhr_hr = fit_mtf(x_uhr_hr, y_uhr_hr)

    CSV = "Canon Medical System – Fig 5.csv"
    pathCSV = os.path.join(figuresDir,CSV)
    df = pd.read_csv(pathCSV)

    x_uhr_nrfbp, y_uhr_nrfbp = insert01(df.iloc[1:27,0].to_numpy().astype(float), df.iloc[1:27,1].to_numpy().astype(float))
    rScale_uhr_nrfbp = fit_mtf(x_uhr_nrfbp, y_uhr_nrfbp)
    
    x_uhr_hrfirstbody, y_uhr_hrfirstbody = insert01(df.iloc[1:41,6].to_numpy().astype(float),df.iloc[1:41,7].to_numpy().astype(float))
    rScale_uhr_hrfirstbody = fit_mtf(x_uhr_hrfirstbody, y_uhr_hrfirstbody)

    # NPS
    CSV = "Canon Medical System – Fig 9.csv"
    pathCSV = os.path.join(figuresDir,CSV)
    df = pd.read_csv(pathCSV)

    sx_uhr_nr, sy_uhr_nr = insert01(df.iloc[1:56,0].to_numpy().astype(float), df.iloc[1:56,1].to_numpy().astype(float))
    sx_uhr_hr, sy_uhr_hr = insert01(df.iloc[1:34,2].to_numpy().astype(float), df.iloc[1:34,3].to_numpy().astype(float))

    # MTF Plot
    UHRCT_COLOR = (0,)*3

    plt.figure(figsize=(6,6))

    plt.plot(x_uhr_hr,mtf(rScale_uhr_hr,x_uhr_hr),color=UHRCT_COLOR)
    plt.plot(x_uhr_hr,y_uhr_hr,color=UHRCT_COLOR,marker="o",linestyle="None")

    plt.plot(x_uhr_hrfirstbody,mtf(rScale_uhr_hrfirstbody,x_uhr_hrfirstbody),color=UHRCT_COLOR)
    plt.plot(x_uhr_hrfirstbody,y_uhr_hrfirstbody,color=UHRCT_COLOR,marker="v",linestyle="None")

    plt.plot(x_uhr_nrfbp,mtf(rScale_uhr_nrfbp,x_uhr_nrfbp),color=UHRCT_COLOR)
    plt.plot(x_uhr_nrfbp,y_uhr_nrfbp,color=UHRCT_COLOR,marker="d",linestyle="None")

    plt.xlim([0,30])
    plt.ylim([0,1.1])
    plt.xlabel("Frequency (lp/cm)")
    plt.ylabel("MTF")

    plt.savefig("")

    ##### NPS
    plt.figure(figsize=(6,6))

    plt.plot(sx_uhr_hr,normmax(nps(rScale_uhr_hrfirstbody,sx_uhr_hr)),color=UHRCT_COLOR)

    plt.plot(sx_uhr_hr,normmax(sy_uhr_hr),color=UHRCT_COLOR,marker="v",linestyle="None")
    plt.plot(sx_uhr_hr,normmax(nps(rScale_uhr_hrfirstbody,sx_uhr_hr)),color=UHRCT_COLOR)
    
    plt.plot(sx_uhr_nr,normmax(sy_uhr_nr),color=UHRCT_COLOR,marker="d",linestyle="None")
    plt.plot(sx_uhr_nr,normmax(nps(rScale_uhr_nrfbp,sx_uhr_nr)),color=UHRCT_COLOR)

    plt.xlim([0,30])
    plt.ylim([0,1.1])
    plt.xlabel("Frequency (lp/cm)")
    plt.ylabel("NPS/peak(NPS)")

    # plt.xlim([0,50])
    # plt.ylim([0,1.1])
    # plt.xlabel("Frequency (lp/cm)")
    # plt.ylabel("NPS Shape")

    ##### Fit analytical forms to Gaussian

#### DISCARDED 

    # PCCT_COLOR = (0.3,)*3

    # plt.plot(x_pcct_br96,y_pcct_br96,color=PCCT_COLOR,marker="^",linestyle="None")
    # plt.plot(x_pcct_br96,mtf(rScale_pcct_br96,x_pcct_br96),color=(0,)*3)

    # plt.plot(x_pcct_br76,y_pcct_br76,color=PCCT_COLOR,marker="s",linestyle="None")
    # plt.plot(x_pcct_br76,mtf(rScale_pcct_br76,x_pcct_br76),color=(0,)*3)